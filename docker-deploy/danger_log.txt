2/7We start by implementing the HTTP parser and saving the result into a request or response object. At first, we simply use recv() but noticed that the socket might not transmit the entire data all at once. To deal with this, we first parse the field of content-length, then utilize a while loop to count the received bytes to assure correctness.2/10At first, while forwarding the chunked data, we can receive 304 Not Modified status code but the file format is incorrect. Since the status code is accurate and a while loop is used to receive the data, we should be able to the entire response from the server. In the end, it turns out that we use ．\n・ as the delimiter instead of ．\r\n・.2/14In the beginning, we implement our cache using an unordered_map<string, string>; however, this implementation requires us to re-parse the data before using it. Our bug is originated from the fact that we only save the body rather than the entire HTTP response; therefore, we can・t find the cached data in the future request. Instead, we alter the design by saving the Response object in the map and using the URL as the key to access the cache. This not only saves the parsing step but also fix the bug of missing header file in the cache.2/17While detecting whether the current data is expired or not, I directly use strptime() to read the input string. I can・t compile the input string at first, then find out that there are ．GMT・ characters appended at the end of the string. Modifying the string format can resolve this issue.2/21To assure socket connection is valid, we verify the return value of each function. If there is any connection error, we output the error message and return back to listen_for_connections() to accept other connections.Exception guarantee: To handle exceptions such as socket connection failure or unable to receive the full data, we write a try-catch block before calling listen_for_connections(). This allows us to catch most of the exceptions and continue our service with other threads; therefore, we believe our run function can guarantee strong exception.External failure: In our handle_request() function, we have to parse the input request and detect which request method should we use. If the input method isn・t among GET, POST, and CONNECT, our proxy will respond with 400 Bad Request. While receiving the response from the server, if the status code of the response isn・t 200 or 304, the response must contain an error so we will skip the caching process, record 502 Bad Gateway, and forward the original response from the server back to the client.